"use strict";
/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tf = require("../index");
var jasmine_util_1 = require("../jasmine_util");
var test_util_1 = require("../test_util");
var defaultValue;
jasmine_util_1.describeWithFlags('sparseToDense', test_util_1.ALL_ENVS, function () {
    beforeEach(function () { return defaultValue = tf.scalar(0, 'int32'); });
    it('should work for scalar indices', function () {
        var indices = tf.scalar(2, 'int32');
        var values = tf.scalar(100, 'int32');
        var shape = [6];
        var result = tf.sparseToDense(indices, values, shape, defaultValue);
        expect(result.shape).toEqual(shape);
        expect(result.dtype).toEqual(values.dtype);
        test_util_1.expectArraysClose(result, [0, 0, 100, 0, 0, 0]);
    });
    it('should work for vector', function () {
        var indices = tf.tensor1d([0, 2, 4], 'int32');
        var values = tf.tensor1d([100, 101, 102], 'int32');
        var shape = [6];
        var result = tf.sparseToDense(indices, values, shape, defaultValue);
        expect(result.shape).toEqual(shape);
        expect(result.dtype).toEqual(values.dtype);
        test_util_1.expectArraysClose(result, [100, 0, 101, 0, 102, 0]);
    });
    it('should work for scalar value', function () {
        var indices = tf.tensor1d([0, 2, 4], 'int32');
        var values = tf.scalar(10, 'int32');
        var shape = [6];
        var result = tf.sparseToDense(indices, values, shape, defaultValue);
        expect(result.shape).toEqual(shape);
        expect(result.dtype).toEqual(values.dtype);
        test_util_1.expectArraysClose(result, [10, 0, 10, 0, 10, 0]);
    });
    it('should work for matrix', function () {
        var indices = tf.tensor2d([0, 1, 1, 1], [2, 2], 'int32');
        var values = tf.tensor1d([5, 6], 'float32');
        var shape = [2, 2];
        var result = tf.sparseToDense(indices, values, shape, defaultValue.toFloat());
        expect(result.shape).toEqual(shape);
        expect(result.dtype).toEqual(values.dtype);
        test_util_1.expectArraysClose(result, [0, 5, 0, 6]);
    });
    it('should throw exception if default value does not match dtype', function () {
        var indices = tf.tensor2d([0, 1, 1, 1], [2, 2], 'int32');
        var values = tf.tensor1d([5, 6], 'float32');
        var shape = [2, 2];
        expect(function () { return tf.sparseToDense(indices, values, shape, tf.scalar(1, 'int32')); })
            .toThrowError();
    });
    it('should allow setting default value', function () {
        var indices = tf.tensor2d([0, 1, 1, 1], [2, 2], 'int32');
        var values = tf.tensor1d([5, 6], 'float32');
        var shape = [2, 2];
        var result = tf.sparseToDense(indices, values, shape, tf.scalar(1));
        expect(result.shape).toEqual(shape);
        expect(result.dtype).toEqual(values.dtype);
        test_util_1.expectArraysClose(result, [1, 5, 1, 6]);
    });
    it('no default value passed', function () {
        var indices = tf.tensor2d([0, 1, 1, 1], [2, 2], 'int32');
        var values = tf.tensor1d([5, 6], 'float32');
        var shape = [2, 2];
        var result = tf.sparseToDense(indices, values, shape);
        expect(result.shape).toEqual(shape);
        expect(result.dtype).toEqual(values.dtype);
        test_util_1.expectArraysClose(result, [0, 5, 0, 6]);
    });
    it('should support TensorLike inputs', function () {
        var indices = [[0, 1], [1, 1]];
        var values = [5, 6];
        var shape = [2, 2];
        var result = tf.sparseToDense(indices, values, shape, defaultValue.toFloat());
        expect(result.shape).toEqual(shape);
        expect(result.dtype).toEqual('float32');
        test_util_1.expectArraysClose(result, [0, 5, 0, 6]);
    });
    it('should work with 0-sized tensors', function () {
        var indices = tf.zeros([0], 'int32');
        var values = tf.zeros([0]);
        var defaultValue = tf.scalar(5);
        var result = tf.sparseToDense(indices, values, [3], defaultValue);
        test_util_1.expectArraysClose(result, [5, 5, 5]);
    });
    it('should throw error when indices are not int32', function () {
        var indices = tf.scalar(2, 'float32');
        var values = tf.scalar(100, 'int32');
        var shape = [6];
        expect(function () { return tf.sparseToDense(indices, values, shape, defaultValue); })
            .toThrow();
    });
    it('should throw error when indices rank > 2', function () {
        var indices = tf.tensor3d([1], [1, 1, 1], 'int32');
        var values = tf.tensor1d([100], 'float32');
        var shape = [6];
        expect(function () { return tf.sparseToDense(indices, values, shape, defaultValue); })
            .toThrow();
    });
    it('should throw error when values has rank > 1', function () {
        var indices = tf.tensor1d([0, 4, 2], 'int32');
        var values = tf.tensor2d([1.0, 2.0, 3.0], [3, 1], 'float32');
        var shape = [6];
        expect(function () { return tf.sparseToDense(indices, values, shape, defaultValue); })
            .toThrow();
    });
    it('should throw error when values has wrong size', function () {
        var indices = tf.tensor1d([0, 4, 2], 'int32');
        var values = tf.tensor1d([1.0, 2.0, 3.0, 4.0], 'float32');
        var shape = [6];
        expect(function () { return tf.sparseToDense(indices, values, shape, defaultValue); })
            .toThrow();
    });
});
jasmine_util_1.describeWithFlags('sparseToDense CPU', test_util_1.CPU_ENVS, function () {
    it('should throw error when index out of range', function () {
        var indices = tf.tensor1d([0, 2, 6], 'int32');
        var values = tf.tensor1d([100, 101, 102], 'int32');
        var shape = [6];
        expect(function () { return tf.sparseToDense(indices, values, shape, defaultValue); })
            .toThrow();
    });
});
//# sourceMappingURL=sparse_to_dense_test.js.map