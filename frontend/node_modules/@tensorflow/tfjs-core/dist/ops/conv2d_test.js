"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tf = require("../index");
var jasmine_util_1 = require("../jasmine_util");
var test_util_1 = require("../test_util");
function generateCaseInputs(totalSizeTensor, totalSizeFilter) {
    var inp = new Array(totalSizeTensor);
    var filt = new Array(totalSizeFilter);
    for (var i = 0; i < totalSizeTensor; i++) {
        inp[i] = i + 1;
    }
    for (var i = 0; i < totalSizeFilter; i++) {
        filt[i] = i + 1;
    }
    return { input: inp, filter: filt };
}
jasmine_util_1.describeWithFlags('conv to matmul', test_util_1.PACKED_ENVS, function () {
    it('im2col should not leak memory', function () {
        var inputDepth = 1;
        var inputShape = [2, 2, inputDepth];
        var outputDepth = 1;
        var fSize = 2;
        var pad = 0;
        var stride = 1;
        var dataFormat = 'NHWC';
        var dilation = 1;
        var x = tf.tensor3d([1, 2, 3, 4], inputShape);
        var w = tf.tensor4d([3, 1, 5, 0], [fSize, fSize, inputDepth, outputDepth]);
        var startNumBytes = tf.memory().numBytes;
        tf.conv2d(x, w, stride, pad, dataFormat, dilation);
        var endNumBytes = tf.memory().numBytes;
        expect(endNumBytes - startNumBytes).toEqual(4);
    });
    it('pointwise conv should work when matmul is unpacked', function () {
        var inputDepth = 1001; // this number must be greater than MATMUL_SHARED_DIM_THRESHOLD
        // for matmul to be unpacked
        var inputShape = [3, 3, inputDepth];
        var outputDepth = 1;
        var fSize = 1;
        var pad = 'same';
        var stride = [1, 1];
        var x = tf.randomNormal(inputShape);
        x = x.add(1); // this packs x so we can test the case where we mistakenly
        // want to avoid expensive reshape in pointwise conv2d even
        // though matmul is unpacked
        var w = tf.randomNormal([fSize, fSize, inputDepth, outputDepth]);
        expect(function () { return tf.conv2d(x, w, stride, pad); }).not.toThrow();
    });
});
jasmine_util_1.describeWithFlags('conv2d', test_util_1.ALL_ENVS, function () {
    it('x=[1,4,4,1] f=[1,1,1,3] s=2 d=1 p=same', function () {
        var inputDepth = 1;
        var inputShape = [4, 4, inputDepth];
        var outputDepth = 3;
        var fSize = 1;
        var pad = 'same';
        var stride = [2, 2];
        var x = tf.tensor3d([
            10, 30, 50, 70, 20, 40, 60, 80, -10, -30, -50, -70, -20, -40, -60, -80
        ], inputShape);
        var w = tf.tensor4d([1, 0.5, 1], [fSize, fSize, inputDepth, outputDepth]);
        var result = tf.conv2d(x, w, stride, pad);
        test_util_1.expectArraysClose(result, [10, 5, 10, 50, 25, 50, -10, -5, -10, -50, -25, -50]);
    });
    it('x=[2,2,1] f=[1,1,1,2] s=1 d=1 p=0', function () {
        var inputDepth = 1;
        var inputShape = [2, 2, inputDepth];
        var outputDepth = 1;
        var fSize = 1;
        var pad = 0;
        var stride = 1;
        var x = tf.tensor3d([1, 2, 3, 4], inputShape);
        var w = tf.tensor4d([2], [fSize, fSize, inputDepth, outputDepth]);
        var result = tf.conv2d(x, w, stride, pad);
        test_util_1.expectArraysClose(result, [2, 4, 6, 8]);
    });
    it('x=[2,2,2,1] f=[1,1,1,1] s=1 d=1 p=0', function () {
        var inputDepth = 1;
        var inShape = [2, 2, 2, inputDepth];
        var outputDepth = 1;
        var fSize = 1;
        var pad = 0;
        var stride = 1;
        var x = tf.tensor4d([1, 2, 3, 4, 5, 6, 7, 8], inShape);
        var w = tf.tensor4d([2], [fSize, fSize, inputDepth, outputDepth]);
        var result = tf.conv2d(x, w, stride, pad);
        expect(result.shape).toEqual([2, 2, 2, 1]);
        var expected = [2, 4, 6, 8, 10, 12, 14, 16];
        test_util_1.expectArraysClose(result, expected);
    });
    it('x=[2,2,1] f=[2,2,1,1] s=1 d=1 p=0', function () {
        var inputDepth = 1;
        var inputShape = [2, 2, inputDepth];
        var outputDepth = 1;
        var fSize = 2;
        var pad = 0;
        var stride = 1;
        var dataFormat = 'NHWC';
        var dilation = 1;
        var x = tf.tensor3d([1, 2, 3, 4], inputShape);
        var w = tf.tensor4d([3, 1, 5, 0], [fSize, fSize, inputDepth, outputDepth]);
        var result = tf.conv2d(x, w, stride, pad, dataFormat, dilation);
        test_util_1.expectArraysClose(result, [20]);
    });
    it('x=[4,4,1] f=[2,2,1,1] s=1 d=2 p=0', function () {
        var inputDepth = 1;
        var inputShape = [4, 4, inputDepth];
        var outputDepth = 1;
        var fSize = 2;
        var fSizeDilated = 3;
        var pad = 0;
        var stride = 1;
        var dataFormat = 'NHWC';
        var dilation = 2;
        var noDilation = 1;
        var x = tf.tensor3d([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], inputShape);
        var w = tf.tensor4d([3, 1, 5, 2], [fSize, fSize, inputDepth, outputDepth]);
        // adding a dilation rate is equivalent to using a filter
        // with 0s for the dilation rate
        var wDilated = tf.tensor4d([3, 0, 1, 0, 0, 0, 5, 0, 2], [fSizeDilated, fSizeDilated, inputDepth, outputDepth]);
        var result = tf.conv2d(x, w, stride, pad, dataFormat, dilation);
        var expectedResult = tf.conv2d(x, wDilated, stride, pad, dataFormat, noDilation);
        expect(result.shape).toEqual(expectedResult.shape);
        test_util_1.expectArraysClose(result, expectedResult);
    });
    it('x=[1,3,6,1] f=[2,2,1,1] s=[1,2] d=1 p=valid', function () {
        var inputDepth = 1;
        var inputShape = [1, 3, 6, inputDepth];
        var outputDepth = 1;
        var fSize = 2;
        var pad = 'valid';
        var stride = [1, 2];
        var inputs = generateCaseInputs(1 * 3 * 6 * inputDepth, fSize * fSize);
        var x = tf.tensor4d(inputs.input, inputShape);
        var w = tf.tensor4d(inputs.filter, [fSize, fSize, inputDepth, outputDepth]);
        var result = tf.conv2d(x, w, stride, pad);
        test_util_1.expectArraysClose(result, [58.0, 78.0, 98.0, 118.0, 138.0, 158.0]);
    });
    it('throws when x is not rank 3', function () {
        var inputDepth = 1;
        var outputDepth = 1;
        var fSize = 2;
        var pad = 0;
        var stride = 1;
        // tslint:disable-next-line:no-any
        var x = tf.tensor2d([1, 2, 3, 4], [2, 2]);
        var w = tf.tensor4d([3, 1, 5, 0], [fSize, fSize, inputDepth, outputDepth]);
        expect(function () { return tf.conv2d(x, w, stride, pad); }).toThrowError();
    });
    it('throws when weights is not rank 4', function () {
        var inputDepth = 1;
        var inputShape = [2, 2, inputDepth];
        var pad = 0;
        var stride = 1;
        var x = tf.tensor3d([1, 2, 3, 4], inputShape);
        // tslint:disable-next-line:no-any
        var w = tf.tensor3d([3, 1, 5, 0], [2, 2, 1]);
        expect(function () { return tf.conv2d(x, w, stride, pad); }).toThrowError();
    });
    it('throws when x depth does not match weight depth', function () {
        var inputDepth = 1;
        var wrongInputDepth = 5;
        var inputShape = [2, 2, inputDepth];
        var outputDepth = 1;
        var fSize = 2;
        var pad = 0;
        var stride = 1;
        var x = tf.tensor3d([1, 2, 3, 4], inputShape);
        var w = tf.randomNormal([fSize, fSize, wrongInputDepth, outputDepth]);
        expect(function () { return tf.conv2d(x, w, stride, pad); }).toThrowError();
    });
    it('throws when dimRoundingMode is set and pad is not a number', function () {
        var inputDepth = 1;
        var inputShape = [2, 2, inputDepth];
        var outputDepth = 1;
        var fSize = 2;
        var pad = 'valid';
        var stride = 1;
        var dataFormat = 'NHWC';
        var dilation = 1;
        var dimRoundingMode = 'round';
        var x = tf.tensor3d([1, 2, 3, 4], inputShape);
        var w = tf.randomNormal([fSize, fSize, inputDepth, outputDepth]);
        expect(function () {
            return tf.conv2d(x, w, stride, pad, dataFormat, dilation, dimRoundingMode);
        })
            .toThrowError();
    });
    it('throws when both stride and dilation are greater than 1', function () {
        var inputDepth = 1;
        var inputShape = [2, 2, inputDepth];
        var outputDepth = 1;
        var fSize = 2;
        var pad = 0;
        var stride = [2, 1];
        var dataFormat = 'NHWC';
        var dilation = [1, 2];
        var x = tf.tensor3d([1, 2, 3, 4], inputShape);
        var w = tf.tensor4d([3, 1, 5, 0], [fSize, fSize, inputDepth, outputDepth]);
        expect(function () { return tf.conv2d(x, w, stride, pad, dataFormat, dilation); })
            .toThrowError();
    });
    it('gradient with clones input=[3,3,1] f=[2,2,1,1] s=1 p=0', function () {
        var inputDepth = 1;
        var outputDepth = 1;
        var inputShape = [3, 3, inputDepth];
        var filterSize = 2;
        var stride = 1;
        var pad = 0;
        var filterShape = [filterSize, filterSize, inputDepth, outputDepth];
        var filter = tf.ones(filterShape);
        var x = tf.tensor3d([1, 2, 3, 4, 5, 6, 7, 8, 9], inputShape);
        var dy = tf.tensor3d([3, 1, 2, 0], [2, 2, 1]);
        var grads = tf.grads(function (x, filter) {
            return x.clone().conv2d(filter.clone(), stride, pad).clone();
        });
        var _a = grads([x, filter], dy), dx = _a[0], dfilter = _a[1];
        expect(dx.shape).toEqual(x.shape);
        test_util_1.expectArraysClose(dx, [3, 4, 1, 5, 6, 1, 2, 2, 0]);
        expect(dfilter.shape).toEqual(filterShape);
        test_util_1.expectArraysClose(dfilter, [13, 19, 31, 37]);
    });
    it('gradient x=[2,3,3,1] f=[2,2,1,1] s=1 p=0', function () {
        var inputDepth = 1;
        var outputDepth = 1;
        var inputShape = [2, 3, 3, inputDepth];
        var filterSize = 2;
        var stride = 1;
        var pad = 0;
        var filterShape = [filterSize, filterSize, inputDepth, outputDepth];
        var filter = tf.ones(filterShape);
        var x = tf.tensor4d([1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9], inputShape);
        var dy = tf.tensor4d([3, 1, 2, 0, 3, 1, 2, 0], [2, 2, 2, 1]);
        var grads = tf.grads(function (x, filter) { return x.conv2d(filter, stride, pad); });
        var _a = grads([x, filter], dy), dx = _a[0], dfilter = _a[1];
        expect(dx.shape).toEqual(x.shape);
        test_util_1.expectArraysClose(dx, [3, 4, 1, 5, 6, 1, 2, 2, 0, 3, 4, 1, 5, 6, 1, 2, 2, 0]);
        expect(dfilter.shape).toEqual(filterShape);
        test_util_1.expectArraysClose(dfilter, [13 * 2, 19 * 2, 31 * 2, 37 * 2]);
    });
    it('throws when passed x as a non-tensor', function () {
        var inputDepth = 1;
        var outputDepth = 1;
        var fSize = 1;
        var pad = 0;
        var stride = 1;
        var w = tf.tensor4d([2], [fSize, fSize, inputDepth, outputDepth]);
        expect(function () { return tf.conv2d({}, w, stride, pad); })
            .toThrowError(/Argument 'x' passed to 'conv2d' must be a Tensor/);
    });
    it('throws when passed filter as a non-tensor', function () {
        var inputDepth = 1;
        var inputShape = [2, 2, inputDepth];
        var pad = 0;
        var stride = 1;
        var x = tf.tensor3d([1, 2, 3, 4], inputShape);
        expect(function () { return tf.conv2d(x, {}, stride, pad); })
            .toThrowError(/Argument 'filter' passed to 'conv2d' must be a Tensor/);
    });
    it('accepts a tensor-like object', function () {
        var pad = 0;
        var stride = 1;
        var x = [[[1], [2]], [[3], [4]]]; // 2x2x1
        var w = [[[[2]]]]; // 1x1x1x1
        var result = tf.conv2d(x, w, stride, pad);
        test_util_1.expectArraysClose(result, [2, 4, 6, 8]);
    });
});
jasmine_util_1.describeWithFlags('conv2d webgl', test_util_1.WEBGL_ENVS, function () {
    it('packed input x=[2,1,2] f=[1,1,2,2] s=1 d=1 p=0', function () {
        var inputShape = [2, 1, 2];
        var fSize = 1;
        var pad = 0;
        var stride = 1;
        var x = tf.tensor3d([1, 2, 3, 4], inputShape);
        var w = tf.tensor4d([1, 2, 3, 4], [fSize, fSize, 2, 2]);
        var webglLazilyUnpackFlagSaved = tf.ENV.get('WEBGL_LAZILY_UNPACK');
        tf.ENV.set('WEBGL_LAZILY_UNPACK', true);
        var webglPackBinaryOperationsFlagSaved = tf.ENV.get('WEBGL_PACK_BINARY_OPERATIONS');
        tf.ENV.set('WEBGL_PACK_BINARY_OPERATIONS', true);
        // First conv2D tests conv2D with non-packed input |x|, and the second uses
        // packed input |result|.
        var result = tf.conv2d(x, w, stride, pad);
        var result1 = tf.conv2d(result, w, stride, pad);
        tf.ENV.set('WEBGL_LAZILY_UNPACK', webglLazilyUnpackFlagSaved);
        tf.ENV.set('WEBGL_PACK_BINARY_OPERATIONS', webglPackBinaryOperationsFlagSaved);
        test_util_1.expectArraysClose(result, [7, 10, 15, 22]);
        test_util_1.expectArraysClose(result1, [37, 54, 81, 118]);
    });
    it('tf.memory() packed input x=[1,1,1,2] f=[1,1,2,2] s=1 d=1 p=0', function () {
        var inputShape = [1, 1, 1, 2];
        var fSize = 1;
        var pad = 0;
        var stride = 1;
        var xInit = tf.tensor4d([0, 1], inputShape);
        var w = tf.tensor4d([1, 2, 3, 4], [fSize, fSize, 2, 2]);
        var webglLazilyUnpackFlagSaved = tf.ENV.get('WEBGL_LAZILY_UNPACK');
        tf.ENV.set('WEBGL_LAZILY_UNPACK', true);
        var webglPackBinaryOperationsFlagSaved = tf.ENV.get('WEBGL_PACK_BINARY_OPERATIONS');
        tf.ENV.set('WEBGL_PACK_BINARY_OPERATIONS', true);
        var x = xInit.add(1);
        var result = tf.conv2d(x, w, stride, pad);
        tf.ENV.set('WEBGL_LAZILY_UNPACK', webglLazilyUnpackFlagSaved);
        tf.ENV.set('WEBGL_PACK_BINARY_OPERATIONS', webglPackBinaryOperationsFlagSaved);
        test_util_1.expectArraysClose(result, [7, 10]);
        result.dispose();
        x.dispose();
        xInit.dispose();
        w.dispose();
        expect(tf.memory().numBytesInGPU).toBe(0);
        expect(tf.memory().numBytes).toBe(0);
    });
});
//# sourceMappingURL=conv2d_test.js.map