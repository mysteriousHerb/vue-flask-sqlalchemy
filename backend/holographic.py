import numpy as np
import json

# ''' When supplying with a descriptor, split with holographic encryption and return the server_descriptor and user_descriptor '''
class HolographicEncryptionClassBuilder():
    def __init__(self):
        pass
            
    def read_descriptor(self, descriptor):
        descriptor = np.array(descriptor)
        # change the value between 0 to 1 
        descriptor = descriptor + 0.5
        # wrap around as a matrix
        descriptor = descriptor.reshape([8,16])
        return descriptor

    def encoding(self, descriptor, iteration_num=100):
        ''' return AbsMask, PhMask, one for user, one for the server '''
        descriptor = self.read_descriptor(descriptor)
        # Target = is the image (with values between 0 and 1) to encode into two masks 
        # Iteration_num = is the number of iteration useful to obtain a good econding (>100)
        Target = descriptor
        avgl=np.mean(Target);

        # np.fft.fftshift Shift the zero-frequency component to the center of the spectrum.
        # https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.fftshift.html
        # np.fft.ifft2 Compute the 2-dimensional inverse discrete Fourier Transform.
        # https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.fft.ifft2.html

        A = np.fft.fftshift(np.fft.ifft2(np.fft.fftshift(Target)));
        # Random Amplitude mash
        AbsMask=np.random.rand(*Target.shape);   
        AbsMask=AbsMask/np.mean(AbsMask)*avgl;

        rmse = []
        for i in range(1,iteration_num):
            B = abs(AbsMask) * np.exp(1j*np.angle(A));
            C = np.fft.fftshift(np.fft.fft2(np.fft.fftshift(B)));
            
            avg2=np.mean(abs(C));
            C=(C/avg2)*avgl;
            rmse.append(np.mean(np.mean((abs(C)-Target)**2))**0.5)
            
            D = abs(Target) * np.exp(1j*np.angle(C));
            A = np.fft.fftshift(np.fft.ifft2(np.fft.fftshift(D)));


        PhMask = np.angle(A);
        # flatten everything for easy saving
        flat_AbsMask = AbsMask.flatten()
        flat_PhMask = PhMask.flatten()

        return flat_AbsMask, flat_PhMask


    def decoding(self, flat_AbsMask, flat_PhMask):
        # AbsMask = is the amplitude mask generated by the encoding process
        # PhMask = is the phase mask generated by the encoding process

        AbsMask = flat_PhMask.reshape([8,16])
        PhMask = flat_PhMask.reshape([8,16])

        B = abs(AbsMask) * np.exp(1j*PhMask);
        C = np.fft.fftshift(np.fft.fft2(np.fft.fftshift(B)));
        app=abs(C);
        TargetRec=app/np.mean(app)*np.mean(AbsMask);

        flat_TargetRec = TargetRec.flatten()
        flat_TargetRec = flat_TargetRec - 0.5

        return flat_TargetRec


if __name__ == "__main__":
    HolographicEncryptionClass = HolographicEncryptionClassBuilder()
    with open(r'temp\data.json') as file:
        descriptor = json.load(file)
    known_descriptor =  descriptor['known_descriptor']
    # print(known_descriptor)
    flat_AbsMask, flat_PhMask = HolographicEncryptionClass.encoding(known_descriptor)
    flat_TargetRec = HolographicEncryptionClass.decoding(flat_AbsMask, flat_PhMask)
    print(known_descriptor)
    print(flat_TargetRec)
