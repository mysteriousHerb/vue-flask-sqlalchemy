import numpy as np
import json
import time

# ''' When supplying with a descriptor, split with holographic encryption and return the server_descriptor and user_descriptor '''
class HolographicEncryptionClassBuilder():
    def __init__(self):
        pass
            
    def read_descriptor(self, descriptor):
        self.descriptor = descriptor
        self.Target = np.array(descriptor)
        # change the value between 0 to 1 
        self.Target = self.Target + 0.5
        # wrap around as a matrix
        self.Target = self.Target.reshape([8,16])

    def encoding(self, Target, iteration_num=100):
        ''' return AbsMask, PhMask, one for user, one for the server '''
        # Target = is the image (with values between 0 and 1) to encode into two masks 
        # Iteration_num = is the number of iteration useful to obtain a good econding (>100)
        avgl=np.mean(Target);

        # np.fft.fftshift Shift the zero-frequency component to the center of the spectrum.
        # https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.fftshift.html
        # np.fft.ifft2 Compute the 2-dimensional inverse discrete Fourier Transform.
        # https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.fft.ifft2.html

        A = np.fft.fftshift(np.fft.ifft2(np.fft.fftshift(Target)));
        # Random Amplitude mash
        AbsMask=np.random.rand(*Target.shape);   
        AbsMask=AbsMask/np.mean(AbsMask)*avgl;

        rmse = []
        for i in range(1,iteration_num):
            B = abs(AbsMask) * np.exp(1j*np.angle(A));
            C = np.fft.fftshift(np.fft.fft2(np.fft.fftshift(B)));
            
            avg2=np.mean(abs(C));
            C=(C/avg2)*avgl;
            rmse.append(np.mean(np.mean((abs(C)-Target)**2))**0.5)
            
            D = abs(Target) * np.exp(1j*np.angle(C));
            A = np.fft.fftshift(np.fft.ifft2(np.fft.fftshift(D)));


        PhMask = np.angle(A);
        # flatten everything for easy saving
        AbsMask_flat = AbsMask.flatten()
        PhMask_flat = PhMask.flatten()

        return AbsMask_flat, PhMask_flat
        # return AbsMask, PhMask


    def decoding(self, AbsMask_flat, PhMask_flat):
    # def decoding(self, AbsMask, PhMask):

        # AbsMask is the amplitude mask generated by the encoding process
        # PhMask is the phase mask generated by the encoding process
        AbsMask = np.array(AbsMask_flat).reshape([8,16])
        PhMask = np.array(PhMask_flat).reshape([8,16])

        B = abs(AbsMask) * np.exp(1j*PhMask);
        C = np.fft.fftshift(np.fft.fft2(np.fft.fftshift(B)));
        app=abs(C);
        TargetRec=app/np.mean(app)*np.mean(AbsMask);

        DescriptorRec = TargetRec - 0.5
        DescriptorRec = DescriptorRec.flatten()

        return DescriptorRec

    def find_optimal_encoding(self, iteration_num=500, number_of_runs=10):
        ''' iteration_num determines the theoretical minimal dist, number_of_runs increases chances of finding it '''
        AbsMask_flat_list = []
        PhMask_flat_list = []
        euclidean_dist_list = []
        for i in range(number_of_runs):
            AbsMask_flat, PhMask_flat = self.encoding(Target=self.Target, iteration_num=500)
            DescriptorRec = self.decoding(AbsMask_flat, PhMask_flat)

            AbsMask_flat_list.append(AbsMask_flat)
            PhMask_flat_list.append(PhMask_flat)
            euclidean_dist_list.append(np.linalg.norm(self.descriptor-DescriptorRec))
        
        # print(euclidean_dist_list)
        optimal_run = np.argmin(euclidean_dist_list)
        print('the optimal distance is: {}'.format(euclidean_dist_list[optimal_run]))
        return AbsMask_flat_list[optimal_run], PhMask_flat_list[optimal_run]



if __name__ == "__main__":
    HolographicEncryptionClass = HolographicEncryptionClassBuilder()
    with open(r'temp\temp.json') as file:
        descriptor = json.load(file)
    known_descriptor =  descriptor['known_descriptor']
    HolographicEncryptionClass.read_descriptor(known_descriptor)
    AbsMask_flat, PhMask_flat = HolographicEncryptionClass.find_optimal_encoding(iteration_num=5000, number_of_runs=10)
    DescriptorRec = HolographicEncryptionClass.decoding(AbsMask_flat,PhMask_flat)

    # while True:
    #     start = time.time()
    #     AbsMask_flat, PhMask_flat = HolographicEncryptionClass.find_optimal_encoding(iteration_num=5000, number_of_runs=10)
    #     end = time.time()
    #     print('finish in')
    #     print(end-start)
    #     print()


    # print(known_descriptor)
    # print(flat_TargetRec)
